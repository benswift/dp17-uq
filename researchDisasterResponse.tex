\subsubsection*{ Live Human-Factors Optimisation for Software Development}

% GOMS model for co-operative scenarios where someone wants
% information, and someone is trying to present it to them

% it's about chunking complex tasks c.f. beginning-middle-end

% the goal: quantitative requirements on the time bounds, which has
% implications for the design of the systems

Similar to Ramchurn et al.~\parencite{ramchurn2016human} 
we will employ {\em game
scenarios} to understand and optimise collaboration for disaster
response~\parencite{ramchurn2016human}. Our focus will be on
decision-maker/modeller communication (rather than the human/agent
communication of ~\parencite{ramchurn2016human}) and our game scenarios 
will take place while software
and systems parameters, particularly the human-computer interface,
visualisations and system configuration, are being tuned in real time
by a live coder. In a novel approach particular to this project, the protocols obtained from
live coding will then be analysed to determine macro ``chunking''
states, of human action and transitions between those states. We have
recently used similar approaches to understand the real-time actions
of single live-coders in computer music
performance~\parencite{swift2014coding} and the macro-gesture states
of group computer musicians using
iPads~\parencite{martin2015tracking}. In both of these studies,
transition matrices derived from interaction protocols were able to
yield insights into the artistic process. In the case of the present
project, data from the interaction protocols of the live-coder will be
feed back into redesign of the software interface and the controls
needed for the computational platform.

By way of one simple example, we imagine that, perhaps, the live coder
finds that a particular measure of uncertainty, \emph{measure-A}, is
routinely requested by a decision maker after another particular
measure, \emph{measure-B}. The live coder could tune up the software
in real time so that these two measures could be presented together.
The interaction protocols in this instance might reveal insights into
the \emph{context} where these two measures were requested one after
the other and the software might be redesigned to recognise that
context and to make the two measures accessible in that context. For
another simple example, the live-coding protocol might show that data
processing needed to be occasionally shifted from one part of a cloud
resource to a local cluster. Examination of these instances could
impact on the computer systems settings needed to properly deploy
these simulations. Our approach to protocol analysis will go well
beyond simple examples like these and will use matrix theory to derive
insights into the nature of state transitions across entire protocols
and across test participants.

